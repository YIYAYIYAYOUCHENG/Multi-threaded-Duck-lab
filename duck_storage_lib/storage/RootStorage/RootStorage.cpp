/*
 * This file is part of duck-lab.
 * 
 * Copyright (c) 
 * 2012 - Christian Nastasi, Claudio Salvadori 
 *
 * duck-lab is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * duck-lab is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301  USA
 */
/** 
* @file RootStorage.cpp
* @brief RootStorage Implementation File
* @author Christian Nastasi c.nastasi@sssup.it, nastasichr@gmail.com
* @author Claudio Salvadori c.salvadori@sssup.it
* @version 1.0
* @date 2012-02-27
*/
#include "RootStorage.h"
#include "RootStorageEvent.h"
#include "RootStorageConfig.h"
#include "StorageConfig.h"
#include "StorageFactory.h"
#include "StorageException.h"

#include "Data.h"
#include "DataFactory.h"
#include "DuckConfig.h"
#include "DuckLog.h"

#include "TTree.h"
#include "TFile.h"

#include <fstream>
#include <sstream>
#include <libgen.h>

#undef CPP_TEMPLATE_FILE
#define CPP_TEMPLATE_FILE \
	DUCK_INSTALL_DIR "data/RootStorage_PostProcessingTemplate.cppdata" 

#ifdef DUCK_USE_NAMESPACE
using namespace duck;
#endif
using namespace std;

DUCK_REGISTER_STORAGE_CLASS(RootStorageConfig::storage_name, RootStorage);

RootStorage::RootStorage(const StorageConfig& c)
{
	const RootStorageConfig& cfg=dynamic_cast<const RootStorageConfig&>(c);

	DUCK_DBG("RootStorage: Constructor: " <<
		 "create_file(" << cfg.get_root_filename() << ")");

	root_event = new RootStorageEvent();
	root_event->init_data(cfg.get_data_subset());

	root_file = new TFile(cfg.get_root_filename().c_str(), "RECREATE");
	root_tree = new TTree(cfg.get_tree_name().c_str(), 
			      cfg.get_tree_title().c_str());
	if (cfg.get_tree_autosave() != 0)
		root_tree->SetAutoSave(cfg.get_tree_autosave());
	else
		root_tree->SetAutoSave(root_event->get_event_size());
	root_tree->SetBranchStyle(1); // FIXME: Hard-Coded! is this OK? 

	root_branch = root_tree->Branch(cfg.get_event_name().c_str(), 
					"RootStorageEvent", &root_event, 
					root_event->get_event_size(), -1);
//	root_branch->SetAutoDelete(kFALSE);
	generate_postproc_code(cfg);
} 

RootStorage::~RootStorage()
{
	DUCK_DBG("RootStorage: Destructor");

	if (root_tree)
		root_tree->Write();
	if (root_event)
		delete root_event;
	if (root_tree)
		delete root_tree;
	if (root_file)
		delete root_file;
}

void RootStorage::store(const vector<Data*>& data)
{
	DUCK_DBG("RootStorage: Attempt to STORE");
	root_event->update_data(data);
	root_tree->Fill();
}

void RootStorage::generate_postproc_code(const RootStorageConfig& cfg)
{ 
	DUCK_LOG("RenderRootStorage: Generating Post-Processing file '" <<
		 cfg.get_postproc_filename() << "' ('' = DO NOTHING)");

	if (cfg.get_postproc_filename() == "")
		return;
	ofstream os(cfg.get_postproc_filename().c_str());

	// Add header of file
	os << "// -------------------------------------------------- //" <<
	      endl <<
	      "// This coode has been generated by RootStorage" <<
	      endl <<
	      "// duck-library built on  " __DATE__ "  " __TIME__ <<
	      endl <<
	      "// -------------------------------------------------- //" <<
	      endl;
	os << "#define DUCK_POSTPROC_ROOT_FILE \"" << cfg.get_root_filename() <<
	      "\"" << endl;
	os << "#define DUCK_POSTPROC_ROOT_TREE \"" << cfg.get_tree_name() <<
	      "\"" << endl;
	os << "#define DUCK_POSTPROC_ROOT_EVENT \"" << cfg.get_event_name() <<
	      "\"" << endl;
	vector<const Data*> vec = cfg.get_data_subset();
	vector<const Data*>::const_iterator i;
	for (i = vec.begin(); i != vec.end(); ++i) 
		os << "#include \"" << 
		   DataFactory::class_inc_file((*i)->get_type())
		   << "\"" << endl;
	os << endl << 
	      "/* -------------------------------------------------------------"
	      << endl;
	os << "                      HOW TO BUILD" << endl << endl <<
	      "g++ -g -Wall \\" << endl <<
	// TODO: use the `duck-config --cflags --ldflags` instead!
	      "    " DUCK_CONFIG_DISTRIB_CFLAGS "\\" << endl <<
	      "    -I`root-config --cflags` \\" << endl <<
	      "    " DUCK_CONFIG_DISTRIB_LDFLAGS "\\" << endl <<
	      "    `root-config --libs`\\" << endl <<
	      "    " << cfg.get_postproc_filename() << 
	      " -o post_processing_app" << endl << endl <<
	      "NOTE: you might need to change the DUCK paths" << endl <<
	      "------------------------------------------------------------- */"
	      << endl << endl;
	// Append template file
	string line;
	ifstream in_f(CPP_TEMPLATE_FILE);
	if (in_f.is_open() && in_f.good()) {
		while (!in_f.eof()) {
			getline (in_f,line);
			os << line << endl;
		}
		in_f.close();
	} else {
		os << "// --->>> ERROR: Unable to find the template file '"
		      CPP_TEMPLATE_FILE"'" << endl;
		os << "//               Generate only the possible "
		      "post-processing function'" << endl;
		os << "bool post_processing(int event_id, "
		      "vector<Data*> d_vect)" << endl;
	}
	// Append post-processing function body
	os << "{" << endl;
	unsigned id = 1;
	for (i = vec.begin(); i != vec.end(); ++i, id++) {
		ostringstream s_obj_name;
		s_obj_name << "data_" << id;
		string obj_type = DataFactory::class_name((*i)->get_type());
		os << "\t" << obj_type << " *" << s_obj_name.str() << " = " <<
		      "static_cast<" << obj_type <<"*>(d_vect[" << id - 1 << 
		      "]);" << "\t// data_name='" << (*i)->get_name() << 
		      "'" << endl;
	}
	os << endl;
	os << "\t// - - - - - - - - - - - - - - - - - - - - - - - - - - - - //"
	   << endl;
	os << "\t// Write your post-processing code here.                   //"
	   << endl;
	os << "\t//                                                         //"
	   << endl;
	os << "\t// Some hints:                                             //"
	   << endl;
	os << "\t//  data_n->data     : head of the data array              //"
	   << endl;
	os << "\t//  data_n->get_len(): lenth of the data array (num elems) //"
	   << endl;
	os << "\t// - - - - - - - - - - - - - - - - - - - - - - - - - - - - //"
	   << endl << endl;
	os << "\treturn true;" << endl;
	os << "}" << endl;
	os.close();
}
