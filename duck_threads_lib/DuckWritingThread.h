#ifndef _DuckWritingThread_h__
#define _DuckWritingThread_h__

#include "DuckBuffer.h"
#include <boost/thread.hpp>
#include <vector>
#include "DuckThread.h"

#ifdef DUCK_USE_NAMESPACE
namespace duck {
#endif

/**
* @brief writing thread for a duck buffer
* @tparam T the type of elements that can be stored in a duck buffer
* @tparam Src the type of object where elements are supplied
*/
template<class T, class Src>
class DuckWritingThread : public DuckLoopThread {
public :
	/**
	* @param loops the parameter for father class DuckLoopThread
	*/
	DuckWritingThread(Src *src, std::vector<DuckBuffer*> *vector_buffer, 
						unsigned long long  loops)
		: DuckLoopThread(loops), source(src)
	{ 
		std::vector<DuckBuffer*>::iterator i = vector_buffer->begin();
		for( ; i != vector_buffer->end(); i++)
			duck_buffers.push_back(*i);
	}
	/**
	* @brief by default loops is 0 and the job will be repeated endlessly 
	*/
	DuckWritingThread(Src *src, std::vector<DuckBuffer*> *vector_buffer) 
		: source(src)
	{ 
		std::vector<DuckBuffer*>::iterator i = vector_buffer->begin();
		for( ; i != vector_buffer->end(); i++)
			duck_buffers.push_back(*i);
	}
	/**
	* @brief concrete writing operation is defined in job().
	*/
	void job(void) {
		std::vector<DuckBuffer *>::iterator it; 
		T elem;
		
		/**
		* To distribute an element, generated by source, to
		* each buffer registered in duck_buffers vector. Each
		* buffer will get a copy of that element.
		*/
		elem = source->get();
		for( it = duck_buffers.begin(); 
					it != duck_buffers.end(); ++it)
			(*it)->write(&elem);
	}

protected :
	/**
	* @brief pointers to duck buffers are stored in a vector
	*/
	std::vector<DuckBuffer*> duck_buffers;
	/**
	* @brief source of elements to be writen
	*/
	Src *source;
};

#ifdef DUCK_USE_NAMESPACE
};
#endif
#endif
